package ui

import "fmt"

type AutoCompleteData struct {
	Label string `json:"label"`
	Value string `json:"value"`
	Image string `json:"image,omitempty"`
	Emoji string `json:"emoji,omitempty"`
}

type AutoCompleteProps struct {
	Data              []AutoCompleteData
	ID                string
	Name              string
	Placeholder       string
	AllOptionLabel    string
	AllOptionIcon     string
	ShowAllOption     bool
	EventNamespace    string
	ListenToEvents    []string
	NoResultsMessage  string
	SearchPlaceholder string
	PreselectedValue  string
	HasError          bool
}

templ AutoComplete(props AutoCompleteProps) {
	{{
		data, _ := templ.JSONString(props.Data)
		placeholder := props.Placeholder
		if placeholder == "" {
			placeholder = "Please Select"
		}
		allOptionLabel := props.AllOptionLabel
		if allOptionLabel == "" {
			allOptionLabel = "All items"
		}
		allOptionIcon := props.AllOptionIcon
		if allOptionIcon == "" {
			allOptionIcon = "ðŸŒ"
		}
		eventNamespace := props.EventNamespace
		if eventNamespace == "" {
			eventNamespace = "autocomplete"
		}
		noResultsMessage := props.NoResultsMessage
		if noResultsMessage == "" {
			noResultsMessage = "No matches found"
		}
		searchPlaceholder := props.SearchPlaceholder
		if searchPlaceholder == "" {
			searchPlaceholder = "Search"
		}
		showAllOptionStr := "false"
		if props.ShowAllOption {
			showAllOptionStr = "true"
		}

		// JSON-encode strings for safe JS embedding
		placeholderJSON, _ := templ.JSONString(placeholder)
		allOptionLabelJSON, _ := templ.JSONString(allOptionLabel)
		allOptionIconJSON, _ := templ.JSONString(allOptionIcon)
		eventNamespaceJSON, _ := templ.JSONString(eventNamespace)
		idJSON, _ := templ.JSONString(props.ID)
		nameJSON, _ := templ.JSONString(props.Name)
		eventsJSON, _ := templ.JSONString(props.ListenToEvents)
		initialValueJSON, _ := templ.JSONString(props.PreselectedValue)

		initScript := fmt.Sprintf(`{
			allOptions: %s,
			options: [],
			isOpen: false,
			openedWithKeyboard: false,
			selectedOption: null,
			placeholder: %s,
			allOptionLabel: %s,
			allOptionIcon: %s,
			eventNamespace: %s,
			showAllOption: %s,
			listenToEvents: %s,
			fieldId: %s,
			fieldName: %s,
			initialValue: %s,
			
			init() {
				this.refreshOptions();
				
				// Set initial selection if provided
				if (this.initialValue) {
					this.selectByValue(this.initialValue);
				}
				
				// Listen to external events
				(this.listenToEvents || []).forEach(evt =>
              		window.addEventListener(evt, (e) => this.handleExternalEvent(e))
				);
				
 				// Reposition dropdown on scroll/resize - throttle with rAF and only when open
 				const onScroll = () => {
 				  if (this._raf) return;
 				  this._raf = requestAnimationFrame(() => {
 				    this._raf = null;
 				    if (this.isOpen || this.openedWithKeyboard) this.checkDropdownPosition();
 				  });
 				};
 				const attach = () => {
 				  window.addEventListener('scroll', onScroll, { capture: true, passive: true });
 				  window.addEventListener('resize', onScroll);
 				};
 				const detach = () => {
 				  window.removeEventListener('scroll', onScroll, { capture: true });
 				  window.removeEventListener('resize', onScroll);
 				};
 				const updateListeners = () => {
                  (this.isOpen || this.openedWithKeyboard) ? attach() : detach();
                };
                this.$watch('isOpen', updateListeners);
                this.$watch('openedWithKeyboard', updateListeners);
                this.$nextTick(updateListeners);
			},
			
			checkDropdownPosition() {
				// Only proceed if dropdown is actually open
				if (!this.isOpen && !this.openedWithKeyboard) {
					return;
				}

				this.$nextTick(() => {
					const dropdown = this.$refs.dropdown;
					const trigger = this.$refs.trigger;
					if (!dropdown || !trigger) return;
					
					const triggerRect = trigger.getBoundingClientRect();
					const viewportHeight = window.innerHeight;
					const dropdownHeight = dropdown.offsetHeight || dropdown.scrollHeight || 200;
					
					const spaceBelow = viewportHeight - triggerRect.bottom;
					const spaceAbove = triggerRect.top;
					
					// Reset positioning
					dropdown.style.position = 'fixed';
					dropdown.style.left = triggerRect.left + 'px';
					dropdown.style.width = triggerRect.width + 'px';
					dropdown.style.top = 'auto';
					dropdown.style.bottom = 'auto';
					dropdown.style.marginTop = '0';
					dropdown.style.marginBottom = '0';
					
					// Position below if there's space, otherwise above
					if (spaceBelow >= dropdownHeight || spaceBelow > spaceAbove) {
						dropdown.style.top = (triggerRect.bottom + 4) + 'px';
					} else {
						dropdown.style.bottom = (viewportHeight - triggerRect.top + 4) + 'px';
					}
				});
			},
			
			refreshOptions() {
				if (this.showAllOption) {
					const allOption = {
						label: this.allOptionLabel,
						value: '',
						image: '',
						emoji: '',
						isAllOption: true
					}
					this.options = [allOption, ...this.allOptions]
				} else {
					this.options = [...this.allOptions]
				}
			},
			
			setSelectedOption(option) {
				if (option.isAllOption) {
					this.selectedOption = null
					this.$refs.hiddenTextField.value = ''
				} else {
					this.selectedOption = option
					this.$refs.hiddenTextField.value = option.value
				}
				this.isOpen = false
				this.openedWithKeyboard = false

				// Dispatch selection event
				this.$dispatch(this.eventNamespace + '-selected', {
					selectedValue: this.selectedOption ? this.selectedOption.value : '',
					selectedLabel: this.selectedOption ? this.selectedOption.label : this.allOptionLabel,
					selectedOption: this.selectedOption,
					fieldId: this.fieldId,
					fieldName: this.fieldName
				})
			},
			
			clearSelection() {
				this.selectedOption = null
				this.$refs.hiddenTextField.value = ''
				
				this.$dispatch(this.eventNamespace + '-cleared', { 
					fieldId: this.fieldId, 
					fieldName: this.fieldName 
				})
			},
			
			updateOptions(newOptions) {
				this.allOptions = newOptions
				this.refreshOptions()
				// Clear selection if current selection is not in new options
				if (this.selectedOption && !newOptions.find(opt => opt.value === this.selectedOption.value)) {
					this.clearSelection()
				}
			},
			
			selectByValue(value) {
				if (!value) {
					this.clearSelection()
					return
				}
				const option = this.allOptions.find(opt => opt.value === value)
				if (option) {
					this.setSelectedOption(option)
				}
			},
			
			handleExternalEvent(event) {
				const { action, target, options, value } = event.detail
				if (target !== this.fieldId) return
				
				if (action === 'update-options') this.updateOptions(options || [])
				else if (action === 'clear-selection') this.clearSelection()
				else if (action === 'select-value') this.selectByValue(value)
			},
			
			getFilteredOptions(query) {
				const filtered = this.allOptions.filter(option => 
					option.label.toLowerCase().includes(query.toLowerCase())
				)
				
				if (this.showAllOption) {
					const allOption = {
						label: this.allOptionLabel,
						value: '',
						image: '',
						emoji: '',
						isAllOption: true
					}
					this.options = [allOption, ...filtered]
				} else {
					this.options = filtered
				}
				
				const hasResults = this.showAllOption ? this.options.length > 1 : this.options.length > 0
				this.$refs.noResultsMessage.classList.toggle('hidden', hasResults)
			},
			
			handleKeydownOnOptions(event) {
				const k = event.key;
				const isTypeable = (k.length === 1 && /[\p{L}\p{N}]/u.test(k)) || k === 'Backspace';
				if (isTypeable) this.$refs.searchField.focus();
			},

			// Method to handle clicks on trigger
			handleTriggerClick() {
				this.isOpen = !this.isOpen;
				this.openedWithKeyboard = false;
				if (this.isOpen) {
					this.$nextTick(() => this.checkDropdownPosition());
				}
			},

			// Method to handle keyboard navigation
			handleKeyboardOpen() {
				this.openedWithKeyboard = true;
				this.isOpen = false;
				this.$nextTick(() => this.checkDropdownPosition());
			}
		}`, data, placeholderJSON, allOptionLabelJSON, allOptionIconJSON,
			eventNamespaceJSON, showAllOptionStr, eventsJSON, idJSON, nameJSON, initialValueJSON)
	}}
	<!-- Loading spinner (visible before Alpine loads) -->
	<div class="w-full" x-data x-show="false">
		<div
			class={
				"inline-flex h-12 w-full items-center justify-center gap-2 rounded-2xl border px-4 py-3 text-sm shadow-inner ring-1 ring-inset transition-all duration-300",
				templ.KV("bg-red-50/50 border-red-300 ring-red-200", props.HasError),
				templ.KV("bg-gray-50/50 border-gray-200 ring-gray-200", !props.HasError),
			}
		>
			<div class="h-5 w-5 animate-spin rounded-full border-2 border-amber-200 border-t-amber-500"></div>
			<span class="text-gray-500">Loading...</span>
		</div>
	</div>
	<!-- Main component (hidden until Alpine loads) -->
	<div
		x-data={ initScript }
		class="relative w-full"
		x-on:keydown="handleKeydownOnOptions($event)"
		x-on:keydown.esc.window="isOpen = false; openedWithKeyboard = false"
		x-cloak
	>
		<!-- Trigger button -->
		<button
			id={ props.ID }
			type="button"
			class={
				"inline-flex h-12 w-full items-center justify-between gap-2 rounded-2xl border px-4 py-3 text-sm font-medium tracking-wide shadow-inner ring-1 ring-inset transition-all duration-300 hover:bg-white hover:ring-gray-300 focus:bg-white focus:outline-none focus:ring-2 focus:ring-amber-400",
				templ.KV("bg-red-50/50 border-red-300 ring-red-200 text-red-900 placeholder:text-red-400 focus:ring-red-400", props.HasError),
				templ.KV("bg-gray-50/50 border-gray-200 ring-gray-200 text-gray-900 placeholder:text-gray-400", !props.HasError),
			}
			x-on:click="handleTriggerClick()"
			x-on:keydown.down.prevent="handleKeyboardOpen()"
			x-on:keydown.enter.prevent="handleKeyboardOpen()"
			x-on:keydown.space.prevent="handleKeyboardOpen()"
			x-ref="trigger"
		>
			<div class="flex min-w-0 items-center gap-2">
				<!-- All option icon (when no selection and showAllOption is true) -->
				<span
					x-show="!selectedOption && showAllOption"
					class="flex-shrink-0 text-base"
					x-text="allOptionIcon"
				></span>
				<!-- Selected item emoji -->
				<span
					x-show="selectedOption && selectedOption.emoji && !selectedOption.image"
					class="flex-shrink-0 text-base"
					x-text="selectedOption ? selectedOption.emoji : ''"
				></span>
				<!-- Selected item image (takes priority over emoji) -->
				<img
					class="h-3.5 w-5 flex-shrink-0 object-contain"
					x-show="selectedOption && selectedOption.image"
					x-bind:src="selectedOption ? selectedOption.image : ''"
					alt=""
				/>
				<!-- Selected option label -->
				<span
					class="truncate text-sm font-normal"
					x-text="selectedOption ? selectedOption.label : (showAllOption ? allOptionLabel : placeholder)"
				></span>
			</div>
			<!-- Chevron -->
			<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="size-5 flex-shrink-0 text-gray-400">
				<path fill-rule="evenodd" d="M5.22 8.22a.75.75 0 0 1 1.06 0L10 11.94l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z" clip-rule="evenodd"></path>
			</svg>
		</button>
		<!-- Hidden Input To Grab The Selected Value -->
		<input
			id={ fmt.Sprintf("%s-hidden", props.ID) }
			type="hidden"
			name={ props.Name }
			autocomplete="off"
			x-ref="hiddenTextField"
			x-bind:value="selectedOption ? selectedOption.value : ''"
		/>
		<!-- Dropdown -->
		<div
			x-show="isOpen || openedWithKeyboard"
			class="fixed z-50 overflow-hidden rounded-2xl border border-gray-200 bg-white shadow-lg ring-1 ring-gray-200/50"
			style="display: none;"
			x-on:click.outside="isOpen = false; openedWithKeyboard = false"
			x-on:keydown.down.prevent="$focus.wrap().next()"
			x-on:keydown.up.prevent="$focus.wrap().previous()"
			x-transition
			x-trap="openedWithKeyboard"
			x-ref="dropdown"
		>
			<!-- Search -->
			<div class="relative border-b border-gray-200/70 bg-gradient-to-r from-white via-gray-50 to-white">
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" fill="none" stroke-width="1.5" class="size-5 absolute left-4 top-1/2 -translate-y-1/2 text-amber-500">
					<path stroke-linecap="round" stroke-linejoin="round" d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607Z"></path>
				</svg>
				<input
					type="text"
					class="w-full border-0 bg-transparent py-3 pl-11 pr-4 text-sm text-gray-900 placeholder:text-gray-400 focus:outline-none focus:ring-0"
					name="searchField"
					autocomplete="off"
					x-on:input="getFilteredOptions($el.value)"
					x-ref="searchField"
					placeholder={ searchPlaceholder }
				/>
			</div>
			<!-- Options -->
			<ul class="flex max-h-44 flex-col overflow-y-auto">
				<li
					class="hidden px-4 py-3 text-sm text-gray-500"
					x-ref="noResultsMessage"
				>
					<span>{ noResultsMessage }</span>
				</li>
				<template
					x-for="(item, index) in options"
					x-bind:key="item.value || 'all'"
				>
					<li
						class="inline-flex cursor-pointer justify-between gap-6 bg-white px-4 py-3 text-sm text-gray-900 transition-all duration-200 hover:bg-gradient-to-r hover:from-gray-50/50 hover:to-gray-100/30 focus-visible:bg-gradient-to-r focus-visible:from-gray-50/50 focus-visible:to-gray-100/30 focus-visible:outline-none"
						x-on:click="setSelectedOption(item)"
						x-on:keydown.enter="setSelectedOption(item)"
						tabindex="0"
					>
						<div class="flex min-w-0 items-center gap-2">
							<!-- All option icon -->
							<span
								x-show="item.isAllOption"
								class="flex-shrink-0 text-base"
								x-text="allOptionIcon"
							></span>
							<!-- Item emoji (shown when no image and emoji exists) -->
							<span
								x-show="!item.isAllOption && item.emoji && !item.image"
								class="flex-shrink-0 text-base"
								x-text="item.emoji"
							></span>
							<!-- Item image (takes priority over emoji) -->
							<img
								class="h-3.5 w-5 flex-shrink-0 object-contain"
								x-show="!item.isAllOption && item.image"
								x-bind:src="item.image"
								x-bind:alt="item.label + ' image'"
							/>
							<!-- Label -->
							<span
								x-bind:class="(selectedOption == null && item.isAllOption) || (selectedOption != null && selectedOption == item) ? 'font-bold' : null"
								x-text="item.label"
								class="truncate"
							></span>
						</div>
						<!-- Checkmark -->
						<svg x-cloak x-show="(selectedOption == null && item.isAllOption) || (selectedOption != null && selectedOption == item)" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" fill="none" stroke-width="2" class="size-4 flex-shrink-0">
							<path stroke-linecap="round" stroke-linejoin="round" d="m4.5 12.75 6 6 9-13.5"></path>
						</svg>
					</li>
				</template>
			</ul>
		</div>
	</div>
}
