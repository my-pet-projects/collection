package shared

import "fmt"

type AutoCompleteData struct {
	Label string `json:"label"`
	Value string `json:"value"`
	Image string `json:"image,omitempty"`
	Emoji string `json:"emoji,omitempty"`
}

type AutoCompleteProps struct {
	Data              []AutoCompleteData
	Label             string
	ShowLabel         bool
	ID                string
	Name              string
	Placeholder       string
	AllOptionLabel    string
	AllOptionIcon     string
	ShowAllOption     bool
	EventNamespace    string
	ListenToEvents    []string
	NoResultsMessage  string
	SearchPlaceholder string
}

templ AutoComplete(props AutoCompleteProps) {
	{{
		data, _ := templ.JSONString(props.Data)
		placeholder := props.Placeholder
		if placeholder == "" {
			placeholder = "Please Select"
		}
		allOptionLabel := props.AllOptionLabel
		if allOptionLabel == "" {
			allOptionLabel = "All items"
		}
		allOptionIcon := props.AllOptionIcon
		if allOptionIcon == "" {
			allOptionIcon = "🌐"
		}
		eventNamespace := props.EventNamespace
		if eventNamespace == "" {
			eventNamespace = "autocomplete"
		}
		noResultsMessage := props.NoResultsMessage
		if noResultsMessage == "" {
			noResultsMessage = "No matches found"
		}
		searchPlaceholder := props.SearchPlaceholder
		if searchPlaceholder == "" {
			searchPlaceholder = "Search"
		}
		listenEvents := ""
		if len(props.ListenToEvents) > 0 {
			for i, event := range props.ListenToEvents {
				if i > 0 {
					listenEvents += " "
				}
				listenEvents += fmt.Sprintf("x-on:%s.window=\"handleExternalEvent($event)\"", event)
			}
		}
		showAllOptionStr := "false"
		if props.ShowAllOption {
			showAllOptionStr = "true"
		}

		// Escape single quotes in strings for JavaScript
		placeholderJSON, _ := templ.JSONString(placeholder)
		allOptionLabelJSON, _ := templ.JSONString(allOptionLabel)
		allOptionIconJSON, _ := templ.JSONString(allOptionIcon)
		eventNamespaceJSON, _ := templ.JSONString(eventNamespace)
		idJSON, _ := templ.JSONString(props.ID)
		nameJSON, _ := templ.JSONString(props.Name)

		initScript := fmt.Sprintf(`{
        allOptions: %s,
        options: [],
        isOpen: false,
        openedWithKeyboard: false,
        selectedOption: null,
        placeholder: %s,
        allOptionLabel: %s,
        allOptionIcon: %s,
        eventNamespace: %s,
        showAllOption: %s,
        fieldId: %s,
        fieldName: %s,
        
        init() {
            this.refreshOptions()
        },
        
        refreshOptions() {
            if (this.showAllOption) {
                const allOption = {
                    label: this.allOptionLabel,
                    value: '',
                    image: '',
                    emoji: '',
                    isAllOption: true
                }
                this.options = [allOption, ...this.allOptions]
            } else {
                this.options = [...this.allOptions]
            }
        },
        
        setSelectedOption(option) {
            if (option.isAllOption) {
                this.selectedOption = null
                this.$refs.hiddenTextField.value = ''
            } else {
                this.selectedOption = option
                this.$refs.hiddenTextField.value = option.value
            }
            this.isOpen = false
            this.openedWithKeyboard = false

            // Dispatch selection event
            this.$dispatch(this.eventNamespace + '-selected', {
                selectedValue: this.selectedOption ? this.selectedOption.value : '',
                selectedLabel: this.selectedOption ? this.selectedOption.label : this.allOptionLabel,
                selectedOption: this.selectedOption,
                fieldId: this.fieldId,
                fieldName: this.fieldName
            })
        },
        
        clearSelection() {
            this.selectedOption = null
            this.$refs.hiddenTextField.value = ''
            this.$dispatch(this.eventNamespace + '-cleared', { 
				fieldId: this.fieldId, 
				fieldName: this.fieldName 
			})
        },
        
        updateOptions(newOptions) {
            this.allOptions = newOptions
            this.refreshOptions()
            // Clear selection if current selection is not in new options
            if (this.selectedOption && !newOptions.find(opt => opt.value === this.selectedOption.value)) {
                this.clearSelection()
            }
        },
        
        selectByValue(value) {
            if (!value) {
                this.clearSelection()
                return
            }
            const option = this.allOptions.find(opt => opt.value === value)
            if (option) {
                this.setSelectedOption(option)
            }
        },
        
        handleExternalEvent(event) {
            const { action, target, options, value } = event.detail
            if (target !== this.fieldId) return
            
            if (action === 'update-options') this.updateOptions(options || [])
            else if (action === 'clear-selection') this.clearSelection()
            else if (action === 'select-value') this.selectByValue(value)
        },
        
        getFilteredOptions(query) {
            const filtered = this.allOptions.filter(option => 
                option.label.toLowerCase().includes(query.toLowerCase())
            )
            
            if (this.showAllOption) {
                const allOption = {
                    label: this.allOptionLabel,
                    value: '',
                    image: '',
                    emoji: '',
                    isAllOption: true
                }
                this.options = [allOption, ...filtered]
            } else {
                this.options = filtered
            }
            
            const hasResults = this.showAllOption ? this.options.length > 1 : this.options.length > 0
            this.$refs.noResultsMessage.classList.toggle('hidden', hasResults)
        },
        
        handleKeydownOnOptions(event) {
            const isAlphaNumeric = (event.keyCode >= 65 && event.keyCode <= 90) || 
                                  (event.keyCode >= 48 && event.keyCode <= 57) || 
                                  event.keyCode === 8
            if (isAlphaNumeric) this.$refs.searchField.focus()
        }
    }`, data, placeholderJSON, allOptionLabelJSON, allOptionIconJSON, eventNamespaceJSON, showAllOptionStr, idJSON, nameJSON)
	}}
	<div
		x-data={ initScript }
		class="flex w-full max-w-xs flex-col gap-1"
		x-on:keydown="handleKeydownOnOptions($event)"
		x-on:keydown.esc.window="isOpen = false, openedWithKeyboard = false"
		x-init="init()"
		{ listenEvents }
	>
		if props.ShowLabel {
			<label for={ props.ID } class="text-on-surface dark:text-on-surface-dark w-fit pl-0.5 text-sm">{ props.Label }</label>
		}
		<div class="relative">
			<!-- Trigger button  -->
			<button
				type="button"
				class="border-outline rounded-radius bg-surface-alt text-on-surface focus-visible:outline-primary dark:border-outline-dark dark:bg-surface-dark-alt/50 dark:text-on-surface-dark dark:focus-visible:outline-primary-dark inline-flex w-full items-center justify-between gap-2 border px-4 py-2 text-sm font-medium tracking-wide transition hover:opacity-75 focus-visible:outline-2 focus-visible:outline-offset-2"
				role="combobox"
				aria-controls={ fmt.Sprintf("%sList", props.ID) }
				aria-haspopup="listbox"
				x-on:click="isOpen = ! isOpen"
				x-on:keydown.down.prevent="openedWithKeyboard = true"
				x-on:keydown.enter.prevent="openedWithKeyboard = true"
				x-on:keydown.space.prevent="openedWithKeyboard = true"
				x-bind:aria-expanded="isOpen || openedWithKeyboard"
				x-bind:aria-label="selectedOption ? selectedOption.label : placeholder"
			>
				<div class="flex items-center gap-2">
					<!-- All option icon (when no selection and showAllOption is true) -->
					<span
						x-show="!selectedOption && showAllOption"
						class="text-base"
						x-text="allOptionIcon"
					></span>
					<!-- Selected item emoji -->
					<span
						x-show="selectedOption && selectedOption.emoji && !selectedOption.image"
						class="text-base"
						x-text="selectedOption ? selectedOption.emoji : ''"
					></span>
					<!-- Selected item image (takes priority over emoji) -->
					<img
						class="h-3.5 w-5 object-contain"
						x-show="selectedOption && selectedOption.image"
						x-bind:src="selectedOption ? selectedOption.image : ''"
						alt=""
						aria-hidden="true"
					/>
					<!-- Selected option label -->
					<span
						class="text-sm font-normal"
						x-text="selectedOption ? selectedOption.label : (showAllOption ? allOptionLabel : placeholder)"
					></span>
				</div>
				<!-- Chevron  -->
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="size-5" aria-hidden="true">
					<path fill-rule="evenodd" d="M5.22 8.22a.75.75 0 0 1 1.06 0L10 11.94l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z" clip-rule="evenodd"></path>
				</svg>
			</button>
			<!-- Hidden Input To Grab The Selected Value  -->
			<input
				id={ props.ID }
				type="hidden"
				name={ props.Name }
				autocomplete="off"
				x-ref="hiddenTextField"
				hidden=""
			/>
			<div
				x-show="isOpen || openedWithKeyboard"
				id={ fmt.Sprintf("%sList", props.ID) }
				class="rounded-radius border-outline bg-surface-alt dark:border-outline-dark dark:bg-surface-dark-alt absolute left-0 top-11 z-10 w-full overflow-hidden border"
				role="listbox"
				x-bind:aria-label="'Options list'"
				x-on:click.outside="isOpen = false, openedWithKeyboard = false"
				x-on:keydown.down.prevent="$focus.wrap().next()"
				x-on:keydown.up.prevent="$focus.wrap().previous()"
				x-transition
				x-trap="openedWithKeyboard"
			>
				<!-- Search  -->
				<div class="relative">
					<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" fill="none" stroke-width="1.5" class="size-5 text-on-surface/50 dark:text-on-surface-dark/50 absolute left-4 top-1/2 -translate-y-1/2" aria-hidden="true">
						<path stroke-linecap="round" stroke-linejoin="round" d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607Z"></path>
					</svg>
					<input
						type="text"
						class="border-outline bg-surface-alt text-on-surface focus:outline-hidden focus-visible:border-primary dark:border-outline-dark dark:bg-surface-dark-alt dark:text-on-surface-dark dark:focus-visible:border-primary-dark w-full border-b py-2.5 pl-11 pr-4 text-sm disabled:cursor-not-allowed disabled:opacity-75"
						name="searchField"
						autocomplete="off"
						aria-label="Search"
						x-on:input="getFilteredOptions($el.value)"
						x-ref="searchField"
						placeholder={ searchPlaceholder }
					/>
				</div>
				<!-- Options  -->
				<ul class="flex max-h-44 flex-col overflow-y-auto">
					<li
						class="text-on-surface dark:text-on-surface-dark hidden px-4 py-2 text-sm"
						x-ref="noResultsMessage"
					>
						<span>{ noResultsMessage }</span>
					</li>
					<template
						x-for="(item, index) in options"
						x-bind:key="item.value || 'all'"
					>
						<li
							class="combobox-option bg-surface-alt text-on-surface hover:bg-surface-dark-alt/5 hover:text-on-surface-strong focus-visible:bg-surface-dark-alt/5 focus-visible:text-on-surface-strong focus-visible:outline-hidden dark:bg-surface-dark-alt dark:text-on-surface-dark dark:hover:bg-surface-alt/5 dark:hover:text-on-surface-dark-strong dark:focus-visible:bg-surface-alt/10 dark:focus-visible:text-on-surface-dark-strong inline-flex justify-between gap-6 px-4 py-2 text-sm"
							role="option"
							x-on:click="setSelectedOption(item)"
							x-on:keydown.enter="setSelectedOption(item)"
							x-bind:id="'option-' + index"
							tabindex="0"
						>
							<div class="flex items-center gap-2">
								<!-- All option icon -->
								<span
									x-show="item.isAllOption"
									class="text-base"
									x-text="allOptionIcon"
								></span>
								<!-- Item emoji (shown when no image and emoji exists) -->
								<span
									x-show="!item.isAllOption && item.emoji && !item.image"
									class="text-base"
									x-text="item.emoji"
								></span>
								<!-- Item image (takes priority over emoji) -->
								<img
									class="h-3.5 w-5 object-contain"
									x-show="!item.isAllOption && item.image"
									x-bind:src="item.image"
									x-bind:alt="item.label + ' image'"
									aria-hidden="true"
								/>
								<!-- Label  -->
								<span
									x-bind:class="(selectedOption == null && item.isAllOption) || (selectedOption != null && selectedOption == item) ? 'font-bold' : null"
									x-text="item.label"
								></span>
								<!-- Screen reader 'selected' indicator  -->
								<span
									class="sr-only"
									x-text="(selectedOption == null && item.isAllOption) || (selectedOption != null && selectedOption == item) ? 'selected' : null"
								></span>
							</div>
							<!-- Checkmark  -->
							<svg x-cloak x-show="(selectedOption == null && item.isAllOption) || (selectedOption != null && selectedOption == item)" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" fill="none" stroke-width="2" class="size-4" aria-hidden="true">
								<path stroke-linecap="round" stroke-linejoin="round" d="m4.5 12.75 6 6 9-13.5"></path>
							</svg>
						</li>
					</template>
				</ul>
			</div>
		</div>
	</div>
}
